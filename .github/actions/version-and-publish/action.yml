name: 'Version and Publish'
description: 'Handle versioning and publishing with conventional commits'

inputs:
  npm-token:
    description: 'NPM token for publishing'
    required: true
  github-token:
    description: 'GitHub token for creating releases'
    required: true
  dry-run:
    description: 'Run in dry-run mode'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
  - name: Get Commit Info
    id: commits
    if: github.ref_name == 'develop'
    shell: bash
    run: |
      # Get commits since last tag
      COMMITS=$(git log --format="%s" $(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)..HEAD)

      # Check commit types
      if echo "$COMMITS" | grep -q "^feat!:\|^BREAKING CHANGE"; then
        echo "bump=major" >> $GITHUB_OUTPUT
      elif echo "$COMMITS" | grep -q "^feat:"; then
        echo "bump=minor" >> $GITHUB_OUTPUT
      else
        echo "bump=patch" >> $GITHUB_OUTPUT
      fi

      if [ "${{ inputs.dry-run }}" = "true" ]; then
        echo "Analyzing commits since last tag:"
        echo "$COMMITS"
        echo "Determined version bump: $(cat $GITHUB_OUTPUT | grep bump | cut -d= -f2)"
      fi

  - name: Process Version
    id: version
    shell: bash
    run: |
      BRANCH="${{ github.event_name == 'pull_request' && 'master' || github.ref_name }}"
      CURRENT_VERSION=$(node -p "require('./package.json').version")

      # Function to increment version
      increment_version() {
        local version=$1
        local bump_type=$2
        
        if [ "$bump_type" = "major" ]; then
          echo "$version" | awk -F. '{$1++; $2=0; $3=0; print $1"."$2"."$3}' OFS=.
        elif [ "$bump_type" = "minor" ]; then
          echo "$version" | awk -F. '{$2++; $3=0; print $1"."$2"."$3}' OFS=.
        else
          echo "$version" | awk -F. '{$3++; print $1"."$2"."$3}' OFS=.
        fi
      }

      if [ "$BRANCH" = "master" ]; then
        # For master: remove canary suffix
        NEW_VERSION=$(echo "$CURRENT_VERSION" | sed 's/-canary\.[0-9]*$//')
        NPM_TAG="latest"
        
        # Store the new master version for develop branch calculation
        echo "master_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        
      elif [ "$BRANCH" = "develop" ]; then
        # Get base version without canary
        BASE_VERSION=$(echo "$CURRENT_VERSION" | sed 's/-canary\.[0-9]*$//')
        
        if [ "${{ github.event.pull_request.merged }}" = "true" ]; then
          # If this is after a PR merge to master, increment the minor version
          MASTER_VERSION="${{ steps.version.outputs.master_version }}"
          if [ -n "$MASTER_VERSION" ]; then
            BASE_VERSION=$(increment_version "$MASTER_VERSION" "minor")
          fi
        else
          # Normal develop branch version bump based on conventional commits
          BUMP_TYPE="${{ steps.commits.outputs.bump }}"
          BASE_VERSION=$(increment_version "$BASE_VERSION" "$BUMP_TYPE")
        fi
        
        # Add canary suffix
        if [[ "$CURRENT_VERSION" == *"-canary"* ]]; then
          CANARY_NUM=$(echo "$CURRENT_VERSION" | sed 's/.*-canary\.//')
          NEW_CANARY=$((CANARY_NUM + 1))
        else
          NEW_CANARY=1
        fi
        
        NEW_VERSION="${BASE_VERSION}-canary.${NEW_CANARY}"
        NPM_TAG="canary"
        
      elif [[ "$BRANCH" =~ ^v[0-9]+ ]]; then
        # For version branches: increment patch
        NEW_VERSION=$(increment_version "$CURRENT_VERSION" "patch")
        NPM_TAG="${BRANCH}-latest"
      fi

      if [ "${{ inputs.dry-run }}" = "true" ]; then
        echo "Current version: $CURRENT_VERSION"
        echo "New version: $NEW_VERSION"
        echo "NPM tag: $NPM_TAG"
      fi

      echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
      echo "npm_tag=$NPM_TAG" >> $GITHUB_OUTPUT

  - name: Create Previous Version Branch
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true && inputs.dry-run != 'true'
    shell: bash
    run: |
      CURRENT_VERSION=${{ steps.version.outputs.new_version }}
      MAJOR_VERSION=$(echo "$CURRENT_VERSION" | cut -d. -f1)
      PREV_MAJOR=$((MAJOR_VERSION - 1))
      BRANCH_NAME="v${PREV_MAJOR}"

      # Check if this is a major version bump
      if ! git branch -r | grep -q "origin/$BRANCH_NAME"; then
        echo "Creating maintenance branch $BRANCH_NAME"
        
        # Create and push branch
        git branch $BRANCH_NAME
        git push origin $BRANCH_NAME
        
        # Create branch protection
        curl -X PUT \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Authorization: token ${{ inputs.github-token }}" \
          "https://api.github.com/repos/${{ github.repository }}/branches/${BRANCH_NAME}/protection" \
          -d '{
            "required_status_checks": null,
            "enforce_admins": true,
            "required_pull_request_reviews": {
              "required_approving_review_count": 1
            },
            "restrictions": null
          }'
      fi

  - name: Update Develop After Master PR
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true && inputs.dry-run != 'true'
    shell: bash
    run: |
      # Checkout develop branch
      git fetch origin develop
      git checkout develop

      # Get the new master version and increment minor for develop
      MASTER_VERSION=${{ steps.version.outputs.new_version }}
      NEW_BASE_VERSION=$(echo "$MASTER_VERSION" | awk -F. '{$2++; $3=0; print $1"."$2"."$3}' OFS=.)
      NEW_VERSION="${NEW_BASE_VERSION}-canary.1"

      # Update package versions
      if [ -f "package.json" ]; then
        sed -i "s/\"version\": \".*\"/\"version\": \"$NEW_VERSION\"/" package.json
      fi

      for pkg in packages/*; do
        if [ -f "$pkg/package.json" ]; then
          sed -i "s/\"version\": \".*\"/\"version\": \"$NEW_VERSION\"/" $pkg/package.json
        fi
      done

      # Commit and push changes
      git add package.json packages/*/package.json
      git commit -m "chore: bump version to ${NEW_VERSION} after master release [skip ci]"
      git push origin develop

  # Rest of the steps remain the same...
  - name: Update Package Versions
    if: inputs.dry-run != 'true'
    shell: bash
    run: |
      NEW_VERSION=${{ steps.version.outputs.new_version }}

      # Update root package.json
      if [ -f "package.json" ]; then
        sed -i "s/\"version\": \".*\"/\"version\": \"$NEW_VERSION\"/" package.json
      fi

      # Update all package versions in packages directory
      for pkg in packages/*; do
        if [ -f "$pkg/package.json" ]; then
          sed -i "s/\"version\": \".*\"/\"version\": \"$NEW_VERSION\"/" $pkg/package.json
          
          # Update internal dependencies versions
          PKG_NAME=$(node -p "require('./$pkg/package.json').name")
          for dep_pkg in packages/*; do
            if [ -f "$dep_pkg/package.json" ]; then
              sed -i "s/\"$PKG_NAME\": \".*\"/\"$PKG_NAME\": \"$NEW_VERSION\"/" $dep_pkg/package.json
            fi
          done
        fi
      done

  - name: Git Operations
    if: inputs.dry-run != 'true'
    shell: bash
    run: |
      NEW_VERSION=${{ steps.version.outputs.new_version }}

      # Commit version updates
      git add package.json packages/*/package.json
      git commit -m "chore: update version to ${NEW_VERSION} [skip ci]"
      git push origin ${{ github.ref_name }}

      # Create version tag
      if [ "${{ github.event_name }}" = "pull_request" ] || [[ "${{ github.ref_name }}" =~ ^v[0-9]+ ]]; then
        git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}"
        git push origin "v${NEW_VERSION}"
        
        # For master branch, also update stable tag
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          git tag -a "stable" -m "Latest stable release v${NEW_VERSION}" -f
          git push origin stable -f
        fi
        
        # For version branches, update their latest tags
        if [[ "${{ github.ref_name }}" =~ ^v[0-9]+ ]]; then
          git tag -a "${{ github.ref_name }}-latest" -m "Latest ${{ github.ref_name }} release v${NEW_VERSION}" -f
          git push origin "${{ github.ref_name }}-latest" -f
        fi
      fi

  - name: Publish to NPM
    if: inputs.dry-run != 'true'
    shell: bash
    run: |
      NPM_TAG=${{ steps.version.outputs.npm_tag }}

      # Create NPM config
      echo "//registry.npmjs.org/:_authToken=${{ inputs.npm-token }}" > .npmrc

      # Publish packages
      for pkg in packages/*; do
        if [ -f "$pkg/package.json" ]; then
          cd $pkg
          npm publish --tag $NPM_TAG --access public
          cd ../..
        fi
      done

  - name: Create GitHub Release
    if: (github.event_name == 'pull_request' || github.ref_name != 'develop') && inputs.dry-run != 'true'
    uses: ncipollo/release-action@v1
    with:
      token: ${{ inputs.github-token }}
      tag: v${{ steps.version.outputs.new_version }}
      name: Release v${{ steps.version.outputs.new_version }}
      generateReleaseNotes: true
      makeLatest: ${{ github.event_name == 'pull_request' }}
